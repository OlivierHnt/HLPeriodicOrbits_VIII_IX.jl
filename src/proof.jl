function prove(filename::AbstractString)
    data = load(filename)
    println("Starting the proof for the periodic orbit ", filename, ":")
    print("  ‚Ä¢ C‚ÇÅ = "); showfull(data["C‚ÇÅ"]); print("\n")
    print("  ‚Ä¢ C‚ÇÇ = "); showfull(data["C‚ÇÇ"]); print("\n")
    return _prove_periodic_orbit(data["x"], data["C‚ÇÅ"], data["C‚ÇÇ"], data["ŒΩ"], data["R"])
end

function _prove_periodic_orbit(x, C‚ÇÅ::Interval{Float64}, C‚ÇÇ::Interval{Float64}, ŒΩ::Interval{Float64}, R::Float64)
    n = order(space(space(x)[1]))

    # ensures the numerical approximation satisfies the complex conjugacy symmetry

    x‚ÇÅ, x‚ÇÇ = component(x, 1), component(x, 2)
    for x‚ÇÅ‚±º ‚àà eachcomponent(x‚ÇÅ)
        x‚ÇÅ‚±º .= (x‚ÇÅ‚±º .+ conj.(view(x‚ÇÅ‚±º, n:-1:-n))) ./ 2
        x‚ÇÅ‚±º[0] = real(x‚ÇÅ‚±º[0])
    end
    x‚ÇÇ .= real.(x‚ÇÇ)

    Œ£‚Çä, Œ£‚Çã, N‚ÇÅ, N‚ÇÇ, N‚ÇÉ = eachcomponent(x‚ÇÅ)
    Œ≥ = x‚ÇÇ[1]
    s‚ÇÅ, s‚ÇÇ, s‚ÇÉ, s‚ÇÑ, s‚ÇÖ = sum(Œ£‚Çä), sum(Œ£‚Çã), sum(N‚ÇÅ), sum(N‚ÇÇ), sum(N‚ÇÉ)

    #

    print("    (i)\n        ‚Ä¢ R = ", R, " and ŒΩ = "); showfull(ŒΩ); print("\n")

    space_F = Fourier(2n, 1.0)^5 √ó ParameterSpace()^3
    F = Sequence(space_F, Vector{Complex{Interval{Float64}}}(undef, dimension(space_F)))
    F!(F, x, C‚ÇÅ, C‚ÇÇ)

    domain_DF = Fourier(3n, 1.0)^5 √ó ParameterSpace()^3
    DF = LinearOperator(domain_DF, space_F, Matrix{Complex{Interval{Float64}}}(undef, dimension(space_F), dimension(domain_DF)))
    DF!(DF, x, C‚ÇÅ, C‚ÇÇ)

    A = inv(mid.(project(DF, space_F, space_F)))

    X_Fourier = ‚Ñì¬π(GeometricWeight(ŒΩ))
    X_cartesian_Fourier = NormedCartesianSpace(X_Fourier, ‚Ñì‚àû())
    X = NormedCartesianSpace((X_cartesian_Fourier, NormedCartesianSpace(‚Ñì‚àû(), ‚Ñì‚àû())), ‚Ñì‚àû())

    opnorm_A = opnorm(Interval.(A), X)
    bound_tail_A = inv(Interval(2n+1))

    Y = norm(A * F, X)
    print("        ‚Ä¢ Y = "); showfull(Y); print("\n")

    Z‚ÇÅ = opnorm(A * DF - I, X) +
        bound_tail_A * opnorm_Df(x, X_Fourier) +
        opnorm_A * inv(ŒΩ^(3n+1)) * max(
            1,
            2(abs(s‚ÇÅ) + abs(s‚ÇÇ) + 3(abs(s‚ÇÉ) + abs(s‚ÇÑ) + abs(s‚ÇÖ))),
            abs(s‚ÇÑ)*abs(s‚ÇÖ) + abs(s‚ÇÉ)*abs(s‚ÇÖ) + abs(s‚ÇÉ)*abs(s‚ÇÑ)
            )
    print("        ‚Ä¢ Z‚ÇÅ = "); showfull(Z‚ÇÅ); print("\n")

    Z‚ÇÇ = (opnorm_A + bound_tail_A) *
        (opnorm_‚àÇŒ£‚ÇäDF(x, R, X_Fourier) + opnorm_‚àÇŒ£‚ÇãDF(x, R, X_Fourier) +
        opnorm_‚àÇN‚ÇÅDF(x, R, X_Fourier) + opnorm_‚àÇN‚ÇÇDF(x, R, X_Fourier) + opnorm_‚àÇN‚ÇÉDF(x, R, X_Fourier) +
        opnorm_‚àÇŒ≥DF(x, R, X_Fourier) + 1)
    print("        ‚Ä¢ Z‚ÇÇ = "); showfull(Z‚ÇÇ); print("\n")

    ie = interval_of_existence(Y, Z‚ÇÅ, Z‚ÇÇ, R)
    print("        ‚Ä¢ interval of existence = "); showfull(ie); print("\n")

    #

    if isempty(ie)
        println("    => (i) failed")
    elseif _prove_periodic_orbit_ii(Œ≥, Œ£‚Çä, Œ£‚Çã, N‚ÇÅ, N‚ÇÉ, inf(ie), R, X_Fourier)
        println("    => (i) and (ii) succeeded")
    else
        println("    => (i) succeeded and (ii) failed")
    end

    return ie
end

function _prove_periodic_orbit(x, C‚ÇÅ::Interval{BigFloat}, C‚ÇÇ::Interval{BigFloat}, ŒΩ::Interval{BigFloat}, R::BigFloat)
    n = order(space(space(x)[1]))

    # ensures the numerical approximation satisfies the complex conjugacy symmetry

    x‚ÇÅ, x‚ÇÇ = component(x, 1), component(x, 2)
    for x‚ÇÅ‚±º ‚àà eachcomponent(x‚ÇÅ)
        x‚ÇÅ‚±º .= (x‚ÇÅ‚±º .+ conj.(view(x‚ÇÅ‚±º, n:-1:-n))) ./ 2
        x‚ÇÅ‚±º[0] = real(x‚ÇÅ‚±º[0])
    end
    x‚ÇÇ .= real.(x‚ÇÇ)

    # set some variables in interval with lesser precision

    v = coefficients(x)
    x_‚ÇÜ‚ÇÑ = Sequence(
        space(x),
        complex.(
            Interval.(Float64.(inf.(real.(v)), RoundDown), Float64.(sup.(real.(v)), RoundUp)),
            Interval.(Float64.(inf.(imag.(v)), RoundDown), Float64.(sup.(imag.(v)), RoundUp))
            )
        )
    C‚ÇÅ_‚ÇÜ‚ÇÑ = Interval(Float64(inf(C‚ÇÅ), RoundDown), Float64(sup(C‚ÇÅ), RoundUp))
    C‚ÇÇ_‚ÇÜ‚ÇÑ = Interval(Float64(inf(C‚ÇÇ), RoundDown), Float64(sup(C‚ÇÇ), RoundUp))
    ŒΩ_‚ÇÜ‚ÇÑ = Interval(Float64(inf(ŒΩ), RoundDown), Float64(sup(ŒΩ), RoundUp))
    R_‚ÇÜ‚ÇÑ = Interval(Float64(R, RoundDown), Float64(R, RoundUp))
    Œ£‚Çä_‚ÇÜ‚ÇÑ, Œ£‚Çã_‚ÇÜ‚ÇÑ, N‚ÇÅ_‚ÇÜ‚ÇÑ, N‚ÇÇ_‚ÇÜ‚ÇÑ, N‚ÇÉ_‚ÇÜ‚ÇÑ = eachcomponent(component(x_‚ÇÜ‚ÇÑ, 1))
    Œ≥_‚ÇÜ‚ÇÑ = component(x_‚ÇÜ‚ÇÑ, 2)[1]
    s‚ÇÅ_‚ÇÜ‚ÇÑ, s‚ÇÇ_‚ÇÜ‚ÇÑ, s‚ÇÉ_‚ÇÜ‚ÇÑ, s‚ÇÑ_‚ÇÜ‚ÇÑ, s‚ÇÖ_‚ÇÜ‚ÇÑ = sum(Œ£‚Çä_‚ÇÜ‚ÇÑ), sum(Œ£‚Çã_‚ÇÜ‚ÇÑ), sum(N‚ÇÅ_‚ÇÜ‚ÇÑ), sum(N‚ÇÇ_‚ÇÜ‚ÇÑ), sum(N‚ÇÉ_‚ÇÜ‚ÇÑ)

    #

    print("    (i)\n        ‚Ä¢ R = ", R, " and ŒΩ = "); showfull(ŒΩ); print("\n")

    space_F = Fourier(2n, 1.0)^5 √ó ParameterSpace()^3
    F = Sequence(space_F, Vector{Complex{Interval{BigFloat}}}(undef, dimension(space_F)))
    F!(F, x, C‚ÇÅ, C‚ÇÇ)

    domain_DF = Fourier(3n, 1.0)^5 √ó ParameterSpace()^3
    DF_‚ÇÜ‚ÇÑ = LinearOperator(domain_DF, space_F, Matrix{Complex{Interval{Float64}}}(undef, dimension(space_F), dimension(domain_DF)))
    DF!(DF_‚ÇÜ‚ÇÑ, x_‚ÇÜ‚ÇÑ, C‚ÇÅ_‚ÇÜ‚ÇÑ, C‚ÇÇ_‚ÇÜ‚ÇÑ)

    A_‚ÇÜ‚ÇÑ = inv(mid.(project(DF_‚ÇÜ‚ÇÑ, space_F, space_F)))

    X_Fourier_‚ÇÜ‚ÇÑ = ‚Ñì¬π(GeometricWeight(ŒΩ_‚ÇÜ‚ÇÑ))
    X_‚ÇÜ‚ÇÑ = NormedCartesianSpace((NormedCartesianSpace(X_Fourier_‚ÇÜ‚ÇÑ, ‚Ñì‚àû()), NormedCartesianSpace(‚Ñì‚àû(), ‚Ñì‚àû())), ‚Ñì‚àû())
    X_Fourier = ‚Ñì¬π(GeometricWeight(ŒΩ))
    X = NormedCartesianSpace((NormedCartesianSpace(X_Fourier, ‚Ñì‚àû()), NormedCartesianSpace(‚Ñì‚àû(), ‚Ñì‚àû())), ‚Ñì‚àû())

    opnorm_A_‚ÇÜ‚ÇÑ = opnorm(Interval.(A_‚ÇÜ‚ÇÑ), X_‚ÇÜ‚ÇÑ)
    bound_tail_A_‚ÇÜ‚ÇÑ = inv(Interval(2n+1))

    Y = norm(A_‚ÇÜ‚ÇÑ * F, X)
    print("        ‚Ä¢ Y = "); showfull(Y); print("\n")

    Z‚ÇÅ_‚ÇÜ‚ÇÑ = opnorm(A_‚ÇÜ‚ÇÑ * DF_‚ÇÜ‚ÇÑ - I, X_‚ÇÜ‚ÇÑ) +
        bound_tail_A_‚ÇÜ‚ÇÑ * opnorm_Df(x_‚ÇÜ‚ÇÑ, X_Fourier_‚ÇÜ‚ÇÑ) +
        opnorm_A_‚ÇÜ‚ÇÑ * inv(ŒΩ_‚ÇÜ‚ÇÑ^(3n+1)) * max(
            1,
            2(abs(s‚ÇÅ_‚ÇÜ‚ÇÑ) + abs(s‚ÇÇ_‚ÇÜ‚ÇÑ) + 3(abs(s‚ÇÉ_‚ÇÜ‚ÇÑ) + abs(s‚ÇÑ_‚ÇÜ‚ÇÑ) + abs(s‚ÇÖ_‚ÇÜ‚ÇÑ))),
            abs(s‚ÇÑ_‚ÇÜ‚ÇÑ)*abs(s‚ÇÖ_‚ÇÜ‚ÇÑ) + abs(s‚ÇÉ_‚ÇÜ‚ÇÑ)*abs(s‚ÇÖ_‚ÇÜ‚ÇÑ) + abs(s‚ÇÉ_‚ÇÜ‚ÇÑ)*abs(s‚ÇÑ_‚ÇÜ‚ÇÑ)
            )
    Z‚ÇÅ = Interval(BigFloat(inf(Z‚ÇÅ_‚ÇÜ‚ÇÑ), RoundDown), BigFloat(sup(Z‚ÇÅ_‚ÇÜ‚ÇÑ), RoundUp))
    print("        ‚Ä¢ Z‚ÇÅ = "); showfull(Z‚ÇÅ); print("\n")

    Z‚ÇÇ_‚ÇÜ‚ÇÑ = (opnorm_A_‚ÇÜ‚ÇÑ + bound_tail_A_‚ÇÜ‚ÇÑ) *
        (opnorm_‚àÇŒ£‚ÇäDF(x_‚ÇÜ‚ÇÑ, R_‚ÇÜ‚ÇÑ, X_Fourier_‚ÇÜ‚ÇÑ) + opnorm_‚àÇŒ£‚ÇãDF(x_‚ÇÜ‚ÇÑ, R_‚ÇÜ‚ÇÑ, X_Fourier_‚ÇÜ‚ÇÑ) +
        opnorm_‚àÇN‚ÇÅDF(x_‚ÇÜ‚ÇÑ, R_‚ÇÜ‚ÇÑ, X_Fourier_‚ÇÜ‚ÇÑ) + opnorm_‚àÇN‚ÇÇDF(x_‚ÇÜ‚ÇÑ, R_‚ÇÜ‚ÇÑ, X_Fourier_‚ÇÜ‚ÇÑ) + opnorm_‚àÇN‚ÇÉDF(x_‚ÇÜ‚ÇÑ, R_‚ÇÜ‚ÇÑ, X_Fourier_‚ÇÜ‚ÇÑ) +
        opnorm_‚àÇŒ≥DF(x_‚ÇÜ‚ÇÑ, R_‚ÇÜ‚ÇÑ, X_Fourier_‚ÇÜ‚ÇÑ) + 1)
    Z‚ÇÇ = Interval(BigFloat(inf(Z‚ÇÇ_‚ÇÜ‚ÇÑ), RoundDown), BigFloat(sup(Z‚ÇÇ_‚ÇÜ‚ÇÑ), RoundUp))
    print("        ‚Ä¢ Z‚ÇÇ = "); showfull(Z‚ÇÇ); print("\n")

    ie = interval_of_existence(Y, Z‚ÇÅ, Z‚ÇÇ, R)
    print("        ‚Ä¢ interval of existence = "); showfull(ie); print("\n")

    #

    if isempty(ie)
        println("    => (i) failed")
    elseif _prove_periodic_orbit_ii(Œ≥_‚ÇÜ‚ÇÑ, Œ£‚Çä_‚ÇÜ‚ÇÑ, Œ£‚Çã_‚ÇÜ‚ÇÑ, N‚ÇÅ_‚ÇÜ‚ÇÑ, N‚ÇÉ_‚ÇÜ‚ÇÑ, Float64(inf(ie), RoundUp), R_‚ÇÜ‚ÇÑ, X_Fourier_‚ÇÜ‚ÇÑ)
        println("    => (i) and (ii) succeeded")
    else
        println("    => (i) succeeded and (ii) failed")
    end

    return ie
end

function _prove_periodic_orbit_ii(Œ≥, Œ£‚Çä, Œ£‚Çã, N‚ÇÅ, N‚ÇÉ, inf_r‚ÇÄ, R, X_Fourier)
    println("    (ii)")
    check_1 = iszero(imag(Œ≥)) & (real(Œ≥) > R)
    println("        ‚Ä¢ check 1: Œ≥ ‚àà (0, +‚àû) -> ", check_1)
    check_2 = check_not_identically_zero(Œ£‚Çä, inf_r‚ÇÄ)
    println("        ‚Ä¢ check 2: Œ£‚Çä is not identically zero in [0, 2œÄ) -> ", check_2)
    check_3 = check_not_identically_zero(N‚ÇÅ, inf_r‚ÇÄ)
    println("        ‚Ä¢ check 3: N‚ÇÅ is not identically zero in [0, 2œÄ) -> ", check_3)
    check_4 = check_not_identically_zero(N‚ÇÉ, inf_r‚ÇÄ)
    println("        ‚Ä¢ check 4: N‚ÇÉ is not identically zero in [0, 2œÄ) -> ", check_4)
    bound_DN‚ÇÅ = 4(abs(Œ≥) + inf_r‚ÇÄ) * (norm(Œ£‚Çä, X_Fourier) + inf_r‚ÇÄ) * (norm(N‚ÇÅ, X_Fourier) + inf_r‚ÇÄ)
    check_5 = check_no_zeros(N‚ÇÅ, bound_DN‚ÇÅ, inf_r‚ÇÄ, "N‚ÇÅ", "5")
    println("        ‚Ä¢ check 5: N‚ÇÅ has no zeros in [0, 2œÄ) -> ", check_5)
    bound_DN‚ÇÉ = 2(abs(Œ≥) + inf_r‚ÇÄ) * (norm(N‚ÇÉ, X_Fourier) + inf_r‚ÇÄ) * (norm(Œ£‚Çä, X_Fourier) + inf_r‚ÇÄ + sqrt(Interval(3.0))*(norm(Œ£‚Çã, X_Fourier) + inf_r‚ÇÄ))
    check_6 = check_no_zeros(N‚ÇÉ, bound_DN‚ÇÉ, inf_r‚ÇÄ, "N‚ÇÉ", "6")
    println("        ‚Ä¢ check 6: N‚ÇÉ has no zeros in [0, 2œÄ) -> ", check_6)
    return check_1 & check_2 & check_3 & check_4 & check_5 & check_6
end

#

function F!(F, x, C‚ÇÅ, C‚ÇÇ)
    Œ£‚Çä, Œ£‚Çã, N‚ÇÅ, N‚ÇÇ, N‚ÇÉ = eachcomponent(component(x, 1))
    Œ≥, Œ∑‚ÇÅ, Œ∑‚ÇÇ = component(x, 2)
    s‚ÇÅ, s‚ÇÇ, s‚ÇÉ, s‚ÇÑ, s‚ÇÖ = sum(Œ£‚Çä), sum(Œ£‚Çã), sum(N‚ÇÅ), sum(N‚ÇÇ), sum(N‚ÇÉ)

    F‚ÇÅ, F‚ÇÇ, F‚ÇÉ, F‚ÇÑ, F‚ÇÖ = eachcomponent(component(F, 1))
    F‚ÇÜ = component(F, 2)

    sqrt3 = sqrt(3one(real(eltype(x))))
    ùíü = Derivative(1)

    project!(F‚ÇÅ, 2Œ≥ * ((N‚ÇÇ - N‚ÇÉ) ^ 2 - N‚ÇÅ * (2N‚ÇÅ - N‚ÇÇ - N‚ÇÉ)) + Œ∑‚ÇÅ * Œ£‚Çä - ùíü(Œ£‚Çä))
    project!(F‚ÇÇ, 2Œ≥*sqrt3 * (N‚ÇÉ - N‚ÇÇ) * (N‚ÇÅ - N‚ÇÇ - N‚ÇÉ) - ùíü(Œ£‚Çã))
    project!(F‚ÇÉ, 4Œ≥ * (Œ£‚Çä * N‚ÇÅ) - ùíü(N‚ÇÅ))
    project!(F‚ÇÑ, -2Œ≥ * N‚ÇÇ * (Œ£‚Çä + sqrt3 * Œ£‚Çã) + Œ∑‚ÇÇ - ùíü(N‚ÇÇ))
    project!(F‚ÇÖ, -2Œ≥ * N‚ÇÉ * (Œ£‚Çä - sqrt3 * Œ£‚Çã) - ùíü(N‚ÇÉ))

    F‚ÇÜ[1] = s‚ÇÅ
    F‚ÇÜ[2] = s‚ÇÅ^2 + s‚ÇÇ^2 + s‚ÇÉ^2 + s‚ÇÑ^2 + s‚ÇÖ^2 - 2s‚ÇÉ*s‚ÇÑ - 2s‚ÇÉ*s‚ÇÖ - 2s‚ÇÑ*s‚ÇÖ - C‚ÇÅ
    F‚ÇÜ[3] = s‚ÇÉ*s‚ÇÑ*s‚ÇÖ - C‚ÇÇ

    return F
end

function DF!(DF, x, C‚ÇÅ, C‚ÇÇ)
    Œ£‚Çä, Œ£‚Çã, N‚ÇÅ, N‚ÇÇ, N‚ÇÉ = eachcomponent(component(x, 1))
    Œ≥, Œ∑‚ÇÅ, Œ∑‚ÇÇ = component(x, 2)
    s‚ÇÅ, s‚ÇÇ, s‚ÇÉ, s‚ÇÑ, s‚ÇÖ = sum(Œ£‚Çä), sum(Œ£‚Çã), sum(N‚ÇÅ), sum(N‚ÇÇ), sum(N‚ÇÉ)

    DF .= zero(eltype(DF))
    M‚ÇÅ‚ÇÅ = component(DF, 1, 1)
    ‚àÇŒ£‚ÇäF‚ÇÅ, ‚àÇN‚ÇÅF‚ÇÅ, ‚àÇN‚ÇÇF‚ÇÅ, ‚àÇN‚ÇÉF‚ÇÅ = component(M‚ÇÅ‚ÇÅ, 1, 1), component(M‚ÇÅ‚ÇÅ, 1, 3), component(M‚ÇÅ‚ÇÅ, 1, 4), component(M‚ÇÅ‚ÇÅ, 1, 5)
    ‚àÇŒ£‚ÇãF‚ÇÇ, ‚àÇN‚ÇÅF‚ÇÇ, ‚àÇN‚ÇÇF‚ÇÇ, ‚àÇN‚ÇÉF‚ÇÇ = component(M‚ÇÅ‚ÇÅ, 2, 2), component(M‚ÇÅ‚ÇÅ, 2, 3), component(M‚ÇÅ‚ÇÅ, 2, 4), component(M‚ÇÅ‚ÇÅ, 2, 5)
    ‚àÇŒ£‚ÇäF‚ÇÉ, ‚àÇN‚ÇÅF‚ÇÉ = component(M‚ÇÅ‚ÇÅ, 3, 1), component(M‚ÇÅ‚ÇÅ, 3, 3)
    ‚àÇŒ£‚ÇäF‚ÇÑ, ‚àÇŒ£‚ÇãF‚ÇÑ, ‚àÇN‚ÇÇF‚ÇÑ = component(M‚ÇÅ‚ÇÅ, 4, 1), component(M‚ÇÅ‚ÇÅ, 4, 2), component(M‚ÇÅ‚ÇÅ, 4, 4)
    ‚àÇŒ£‚ÇäF‚ÇÖ, ‚àÇŒ£‚ÇãF‚ÇÖ, ‚àÇN‚ÇÉF‚ÇÖ = component(M‚ÇÅ‚ÇÅ, 5, 1), component(M‚ÇÅ‚ÇÅ, 5, 2), component(M‚ÇÅ‚ÇÅ, 5, 5)
    M‚ÇÅ‚ÇÇ = component(DF, 1, 2)
    DŒ≥F‚ÇÅ, DŒ≥F‚ÇÇ, DŒ≥F‚ÇÉ, DŒ≥F‚ÇÑ, DŒ≥F‚ÇÖ = component(M‚ÇÅ‚ÇÇ, 1, 1), component(M‚ÇÅ‚ÇÇ, 2, 1), component(M‚ÇÅ‚ÇÇ, 3, 1), component(M‚ÇÅ‚ÇÇ, 4, 1), component(M‚ÇÅ‚ÇÇ, 5, 1)
    DŒ∑‚ÇÅF‚ÇÅ = component(M‚ÇÅ‚ÇÇ, 1, 2)
    DŒ∑‚ÇÇF‚ÇÑ = component(M‚ÇÅ‚ÇÇ, 4, 3)
    M‚ÇÇ‚ÇÅ = component(DF, 2, 1)
    ‚àÇŒ£‚ÇäF‚ÇÜ, ‚àÇŒ£‚ÇãF‚ÇÜ, ‚àÇN‚ÇÅF‚ÇÜ, ‚àÇN‚ÇÇF‚ÇÜ, ‚àÇN‚ÇÉF‚ÇÜ = component(M‚ÇÇ‚ÇÅ, :, 1), component(M‚ÇÇ‚ÇÅ, :, 2), component(M‚ÇÇ‚ÇÅ, :, 3), component(M‚ÇÇ‚ÇÅ, :, 4), component(M‚ÇÇ‚ÇÅ, :, 5)

    sqrt3 = sqrt(3one(real(eltype(x))))
    ùíü = Derivative(1)

    # F‚ÇÅ = 2Œ≥ * ((N‚ÇÇ - N‚ÇÉ) ^ 2 - N‚ÇÅ * (2N‚ÇÅ - N‚ÇÇ - N‚ÇÉ)) + Œ∑‚ÇÅ * Œ£‚Çä - ùíü(Œ£‚Çä)
    lsub!(Œ∑‚ÇÅ*I, project!(‚àÇŒ£‚ÇäF‚ÇÅ, ùíü))
    project!(‚àÇN‚ÇÅF‚ÇÅ, Multiplication(-2Œ≥ * (4N‚ÇÅ - N‚ÇÇ - N‚ÇÉ)))
    project!(‚àÇN‚ÇÇF‚ÇÅ, Multiplication(2Œ≥ * (N‚ÇÅ + 2(N‚ÇÇ - N‚ÇÉ))))
    project!(‚àÇN‚ÇÉF‚ÇÅ, Multiplication(2Œ≥ * (N‚ÇÅ - 2(N‚ÇÇ - N‚ÇÉ))))
    project!(Sequence(codomain(DŒ≥F‚ÇÅ), vec(coefficients(DŒ≥F‚ÇÅ))), 2((N‚ÇÇ - N‚ÇÉ) ^ 2 - N‚ÇÅ * (2N‚ÇÅ - N‚ÇÇ - N‚ÇÉ)))
    project!(Sequence(codomain(DŒ∑‚ÇÅF‚ÇÅ), vec(coefficients(DŒ∑‚ÇÅF‚ÇÅ))), Œ£‚Çä)

    # F‚ÇÇ = 2Œ≥ * sqrt(3) * (N‚ÇÉ - N‚ÇÇ) * (N‚ÇÅ - N‚ÇÇ - N‚ÇÉ) - ùíü(Œ£‚Çã)
    project!(‚àÇŒ£‚ÇãF‚ÇÇ, ùíü) .*= -1
    project!(‚àÇN‚ÇÅF‚ÇÇ, Multiplication(2Œ≥*sqrt3 * (N‚ÇÉ - N‚ÇÇ)))
    project!(‚àÇN‚ÇÇF‚ÇÇ, Multiplication(2Œ≥*sqrt3 * (2N‚ÇÇ - N‚ÇÅ)))
    project!(‚àÇN‚ÇÉF‚ÇÇ, Multiplication(2Œ≥*sqrt3 * (N‚ÇÅ - 2N‚ÇÉ)))
    project!(Sequence(codomain(DŒ≥F‚ÇÇ), vec(coefficients(DŒ≥F‚ÇÇ))), 2sqrt3 * (N‚ÇÉ - N‚ÇÇ) * (N‚ÇÅ - N‚ÇÇ - N‚ÇÉ))

    # F‚ÇÉ = 4Œ≥ * Œ£‚Çä * N‚ÇÅ - ùíü(N‚ÇÅ)
    project!(‚àÇŒ£‚ÇäF‚ÇÉ, Multiplication(4Œ≥ * N‚ÇÅ))
    project!(‚àÇN‚ÇÅF‚ÇÉ, Multiplication(4Œ≥ * Œ£‚Çä)) .-= project(ùíü, domain(‚àÇN‚ÇÅF‚ÇÉ), codomain(‚àÇN‚ÇÅF‚ÇÉ), eltype(DF))
    project!(Sequence(codomain(DŒ≥F‚ÇÉ), vec(coefficients(DŒ≥F‚ÇÉ))), 4(Œ£‚Çä * N‚ÇÅ))

    # F‚ÇÑ = -2Œ≥ * N‚ÇÇ * (Œ£‚Çä + sqrt(3) * Œ£‚Çã) + Œ∑‚ÇÇ - ùíü(N‚ÇÇ)
    project!(‚àÇŒ£‚ÇäF‚ÇÑ, Multiplication(-2Œ≥ * N‚ÇÇ))
    project!(‚àÇŒ£‚ÇãF‚ÇÑ, Multiplication(-2Œ≥*sqrt3 * N‚ÇÇ))
    project!(‚àÇN‚ÇÇF‚ÇÑ, Multiplication(-2Œ≥ * (Œ£‚Çä + sqrt3 * Œ£‚Çã))) .-= project(ùíü, domain(‚àÇN‚ÇÇF‚ÇÑ), codomain(‚àÇN‚ÇÇF‚ÇÑ), eltype(DF))
    project!(Sequence(codomain(DŒ≥F‚ÇÑ), vec(coefficients(DŒ≥F‚ÇÑ))), -2N‚ÇÇ * (Œ£‚Çä + sqrt3 * Œ£‚Çã))
    DŒ∑‚ÇÇF‚ÇÑ[0,1] = one(eltype(DF))

    # F‚ÇÖ = -2Œ≥ * N‚ÇÉ * (Œ£‚Çä - sqrt(3) * Œ£‚Çã) - ùíü(N‚ÇÉ)
    project!(‚àÇŒ£‚ÇäF‚ÇÖ, Multiplication(-2Œ≥ * N‚ÇÉ))
    project!(‚àÇŒ£‚ÇãF‚ÇÖ, Multiplication(2Œ≥*sqrt3 * N‚ÇÉ))
    project!(‚àÇN‚ÇÉF‚ÇÖ, Multiplication(-2Œ≥ * (Œ£‚Çä - sqrt3 * Œ£‚Çã))) .-= project(ùíü, domain(‚àÇN‚ÇÉF‚ÇÖ), codomain(‚àÇN‚ÇÉF‚ÇÖ), eltype(DF))
    project!(Sequence(codomain(DŒ≥F‚ÇÖ), vec(coefficients(DŒ≥F‚ÇÖ))), -2N‚ÇÉ * (Œ£‚Çä - sqrt3 * Œ£‚Çã))

    # F‚ÇÜ[1] = sum(Œ£‚Çä)
    ‚àÇŒ£‚ÇäF‚ÇÜ[1,:] .= one(eltype(DF))
    # F‚ÇÜ[2] = sum(Œ£‚Çä)^2 + sum(Œ£‚Çã)^2 + sum(N‚ÇÅ)^2 + sum(N‚ÇÇ)^2 + sum(N‚ÇÉ)^2 - 2sum(N‚ÇÅ)*sum(N‚ÇÇ) - 2sum(N‚ÇÅ)*sum(N‚ÇÉ) - 2sum(N‚ÇÇ)*sum(N‚ÇÉ) - C‚ÇÅ
    ‚àÇŒ£‚ÇäF‚ÇÜ[2,:] .= 2s‚ÇÅ
    ‚àÇŒ£‚ÇãF‚ÇÜ[2,:] .= 2s‚ÇÇ
    ‚àÇN‚ÇÅF‚ÇÜ[2,:] .= 2(s‚ÇÉ - s‚ÇÑ - s‚ÇÖ)
    ‚àÇN‚ÇÇF‚ÇÜ[2,:] .= 2(s‚ÇÑ - s‚ÇÉ - s‚ÇÖ)
    ‚àÇN‚ÇÉF‚ÇÜ[2,:] .= 2(s‚ÇÖ - s‚ÇÉ - s‚ÇÑ)
    # F‚ÇÜ[3] = sum(N‚ÇÅ)*sum(N‚ÇÇ)*sum(N‚ÇÉ) - C‚ÇÇ
    ‚àÇN‚ÇÅF‚ÇÜ[3,:] .= s‚ÇÑ*s‚ÇÖ
    ‚àÇN‚ÇÇF‚ÇÜ[3,:] .= s‚ÇÉ*s‚ÇÖ
    ‚àÇN‚ÇÉF‚ÇÜ[3,:] .= s‚ÇÉ*s‚ÇÑ

    return DF
end

#

function opnorm_Df(x, X_Fourier)
    Œ£‚Çä, Œ£‚Çã, N‚ÇÅ, N‚ÇÇ, N‚ÇÉ = eachcomponent(component(x, 1))
    Œ≥, Œ∑‚ÇÅ, Œ∑‚ÇÇ = component(x, 2)

    sqrt3 = sqrt(3one(real(eltype(x))))

    # f‚ÇÅ = 2Œ≥ * ((N‚ÇÇ - N‚ÇÉ) ^ 2 - N‚ÇÅ * (2N‚ÇÅ - N‚ÇÇ - N‚ÇÉ)) + Œ∑‚ÇÅ * Œ£‚Çä
    v‚ÇÅ = abs(Œ∑‚ÇÅ) + # ‚àÇŒ£‚Çäf‚ÇÅ
        2abs(Œ≥) * norm(4N‚ÇÅ - N‚ÇÇ - N‚ÇÉ, X_Fourier) + # ‚àÇN‚ÇÅf‚ÇÅ
        2abs(Œ≥) * norm(N‚ÇÅ + 2(N‚ÇÇ - N‚ÇÉ), X_Fourier) + # ‚àÇN‚ÇÇf‚ÇÅ
        2abs(Œ≥) * norm(N‚ÇÅ - 2(N‚ÇÇ - N‚ÇÉ), X_Fourier) # ‚àÇN‚ÇÉf‚ÇÅ

    # f‚ÇÇ = 2Œ≥ * sqrt(3) * (N‚ÇÉ - N‚ÇÇ) * (N‚ÇÅ - N‚ÇÇ - N‚ÇÉ)
    v‚ÇÇ = 2abs(Œ≥)*sqrt3 * norm(N‚ÇÉ - N‚ÇÇ, X_Fourier) + # ‚àÇN‚ÇÅf‚ÇÇ
        2abs(Œ≥)*sqrt3 * norm(2N‚ÇÇ - N‚ÇÅ, X_Fourier) + # ‚àÇN‚ÇÇf‚ÇÇ
        2abs(Œ≥)*sqrt3 * norm(N‚ÇÅ - 2N‚ÇÉ, X_Fourier) # ‚àÇN‚ÇÉf‚ÇÇ

    # f‚ÇÉ = 4Œ≥ * Œ£‚Çä * N‚ÇÅ
    v‚ÇÉ = 4abs(Œ≥) * norm(N‚ÇÅ, X_Fourier) + # ‚àÇŒ£‚Çäf‚ÇÉ
        4abs(Œ≥) * norm(Œ£‚Çä, X_Fourier) # ‚àÇN‚ÇÅf‚ÇÉ

    # f‚ÇÑ = -2Œ≥ * N‚ÇÇ * (Œ£‚Çä + sqrt(3) * Œ£‚Çã) + Œ∑‚ÇÇ
    v‚ÇÑ = 2abs(Œ≥) * norm(N‚ÇÇ, X_Fourier) + # ‚àÇŒ£‚Çäf‚ÇÑ
        2abs(Œ≥)*sqrt3 * norm(N‚ÇÇ, X_Fourier) + # ‚àÇŒ£‚Çãf‚ÇÑ
        2abs(Œ≥) * norm(Œ£‚Çä + sqrt3 * Œ£‚Çã, X_Fourier) # ‚àÇN‚ÇÇf‚ÇÑ

    # f‚ÇÖ = -2Œ≥ * N‚ÇÉ * (Œ£‚Çä - sqrt(3) * Œ£‚Çã)
    v‚ÇÖ = 2abs(Œ≥) * norm(N‚ÇÉ, X_Fourier) + # ‚àÇŒ£‚Çäf‚ÇÖ
        2abs(Œ≥)*sqrt3 * norm(N‚ÇÉ, X_Fourier) + # ‚àÇŒ£‚Çãf‚ÇÖ
        2abs(Œ≥) * norm(Œ£‚Çä - sqrt3 * Œ£‚Çã, X_Fourier) # ‚àÇN‚ÇÉf‚ÇÖ

    return max(v‚ÇÅ, v‚ÇÇ, v‚ÇÉ, v‚ÇÑ, v‚ÇÖ)
end

function opnorm_‚àÇŒ£‚ÇäDF(x, r, X_Fourier)
    Œ£‚Çä, Œ£‚Çã, N‚ÇÅ, N‚ÇÇ, N‚ÇÉ = eachcomponent(component(x, 1))
    Œ≥, Œ∑‚ÇÅ, Œ∑‚ÇÇ = component(x, 2)

    n_N‚ÇÅ, n_N‚ÇÇ, n_N‚ÇÉ = norm(N‚ÇÅ, X_Fourier), norm(N‚ÇÇ, X_Fourier), norm(N‚ÇÉ, X_Fourier)

    M‚ÇÅ‚ÇÅ = 4(abs(Œ≥) + r)
    M‚ÇÅ‚ÇÇ = max(1, 4(n_N‚ÇÅ + r), 2(n_N‚ÇÇ + r), 2(n_N‚ÇÉ + r))
    M‚ÇÇ‚ÇÅ = 2

    return max(M‚ÇÅ‚ÇÅ + M‚ÇÅ‚ÇÇ, M‚ÇÇ‚ÇÅ)
end

function opnorm_‚àÇŒ£‚ÇãDF(x, r, X_Fourier)
    Œ£‚Çä, Œ£‚Çã, N‚ÇÅ, N‚ÇÇ, N‚ÇÉ = eachcomponent(component(x, 1))
    Œ≥, Œ∑‚ÇÅ, Œ∑‚ÇÇ = component(x, 2)

    sqrt3 = sqrt(3one(real(eltype(x))))
    n_N‚ÇÇ, n_N‚ÇÉ = norm(N‚ÇÇ, X_Fourier), norm(N‚ÇÉ, X_Fourier)

    M‚ÇÅ‚ÇÅ = 2(abs(Œ≥) + r)*sqrt3
    M‚ÇÅ‚ÇÇ = max(2sqrt3 * (n_N‚ÇÇ + r), 2sqrt3 * (n_N‚ÇÉ + r))
    M‚ÇÇ‚ÇÅ = 2

    return max(M‚ÇÅ‚ÇÅ + M‚ÇÅ‚ÇÇ, M‚ÇÇ‚ÇÅ)
end

function opnorm_‚àÇN‚ÇÅDF(x, r, X_Fourier)
    Œ£‚Çä, Œ£‚Çã, N‚ÇÅ, N‚ÇÇ, N‚ÇÉ = eachcomponent(component(x, 1))
    Œ≥, Œ∑‚ÇÅ, Œ∑‚ÇÇ = component(x, 2)

    sqrt3 = sqrt(3one(real(eltype(x))))
    n_Œ£‚Çä = norm(Œ£‚Çä, X_Fourier)
    n_N‚ÇÅ, n_N‚ÇÇ, n_N‚ÇÉ = norm(N‚ÇÅ, X_Fourier), norm(N‚ÇÇ, X_Fourier), norm(N‚ÇÉ, X_Fourier)

    M‚ÇÅ‚ÇÅ = 12(abs(Œ≥) + r)
    M‚ÇÅ‚ÇÇ = max(2(4n_N‚ÇÅ + n_N‚ÇÇ + n_N‚ÇÉ + 6r), 2sqrt3 * (n_N‚ÇÇ + n_N‚ÇÉ + 2r), 4(n_Œ£‚Çä + r))
    M‚ÇÇ‚ÇÅ = max(6, n_N‚ÇÇ + n_N‚ÇÉ + 2r)

    return max(M‚ÇÅ‚ÇÅ + M‚ÇÅ‚ÇÇ, M‚ÇÇ‚ÇÅ)
end

function opnorm_‚àÇN‚ÇÇDF(x, r, X_Fourier)
    Œ£‚Çä, Œ£‚Çã, N‚ÇÅ, N‚ÇÇ, N‚ÇÉ = eachcomponent(component(x, 1))
    Œ≥, Œ∑‚ÇÅ, Œ∑‚ÇÇ = component(x, 2)

    sqrt3 = sqrt(3one(real(eltype(x))))
    n_Œ£‚Çä, n_Œ£‚Çã = norm(Œ£‚Çä, X_Fourier), norm(Œ£‚Çã, X_Fourier)
    n_N‚ÇÅ, n_N‚ÇÇ, n_N‚ÇÉ = norm(N‚ÇÅ, X_Fourier), norm(N‚ÇÇ, X_Fourier), norm(N‚ÇÉ, X_Fourier)

    M‚ÇÅ‚ÇÅ = 6(abs(Œ≥) + r)*sqrt3
    M‚ÇÅ‚ÇÇ = max(2(n_N‚ÇÅ + 2n_N‚ÇÇ + 2n_N‚ÇÉ + 5r), 2sqrt3 * (n_N‚ÇÅ + 2n_N‚ÇÇ + 3r), 2(n_Œ£‚Çä + r + sqrt3 * (n_Œ£‚Çã + r)))
    M‚ÇÇ‚ÇÅ = max(6, n_N‚ÇÅ + n_N‚ÇÉ + 2r)

    return max(M‚ÇÅ‚ÇÅ + M‚ÇÅ‚ÇÇ, M‚ÇÇ‚ÇÅ)
end

function opnorm_‚àÇN‚ÇÉDF(x, r, X_Fourier)
    Œ£‚Çä, Œ£‚Çã, N‚ÇÅ, N‚ÇÇ, N‚ÇÉ = eachcomponent(component(x, 1))
    Œ≥, Œ∑‚ÇÅ, Œ∑‚ÇÇ = component(x, 2)

    sqrt3 = sqrt(3one(real(eltype(x))))
    n_Œ£‚Çä, n_Œ£‚Çã = norm(Œ£‚Çä, X_Fourier), norm(Œ£‚Çã, X_Fourier)
    n_N‚ÇÅ, n_N‚ÇÇ, n_N‚ÇÉ = norm(N‚ÇÅ, X_Fourier), norm(N‚ÇÇ, X_Fourier), norm(N‚ÇÉ, X_Fourier)

    M‚ÇÅ‚ÇÅ = 6(abs(Œ≥) + r)*sqrt3
    M‚ÇÅ‚ÇÇ = max(2(n_N‚ÇÅ + 2n_N‚ÇÇ + 2n_N‚ÇÉ + 5r), 2sqrt3 * (n_N‚ÇÅ + 2n_N‚ÇÉ + 3r), 2(n_Œ£‚Çä + r + sqrt3 * (n_Œ£‚Çã + r)))
    M‚ÇÇ‚ÇÅ = max(6, n_N‚ÇÅ + n_N‚ÇÇ + 2r)

    return max(M‚ÇÅ‚ÇÅ + M‚ÇÅ‚ÇÇ, M‚ÇÇ‚ÇÅ)
end

function opnorm_‚àÇŒ≥DF(x, r, X_Fourier)
    Œ£‚Çä, Œ£‚Çã, N‚ÇÅ, N‚ÇÇ, N‚ÇÉ = eachcomponent(component(x, 1))
    Œ≥, Œ∑‚ÇÅ, Œ∑‚ÇÇ = component(x, 2)

    sqrt3 = sqrt(3one(real(eltype(x))))
    n_Œ£‚Çä, n_Œ£‚Çã = norm(Œ£‚Çä, X_Fourier), norm(Œ£‚Çã, X_Fourier)
    n_N‚ÇÅ, n_N‚ÇÇ, n_N‚ÇÉ = norm(N‚ÇÅ, X_Fourier), norm(N‚ÇÇ, X_Fourier), norm(N‚ÇÉ, X_Fourier)

    return max(
        2(4n_N‚ÇÅ + n_N‚ÇÇ + n_N‚ÇÉ + 6r) + 4(n_N‚ÇÅ + 2n_N‚ÇÇ + 2n_N‚ÇÉ+ 5r),
        2sqrt3 * (2n_N‚ÇÅ + 3n_N‚ÇÇ + 3n_N‚ÇÉ + 8r),
        4(n_Œ£‚Çä + n_N‚ÇÅ + 2r),
        2(n_N‚ÇÇ + r) + 2sqrt3 * (n_N‚ÇÇ + r) + 2(n_Œ£‚Çä + r + sqrt3 * (n_Œ£‚Çã + r)),
        2(n_N‚ÇÉ + r) + 2sqrt3 * (n_N‚ÇÉ + r) + 2(n_Œ£‚Çä + r + sqrt3 * (n_Œ£‚Çã + r))
        )
end

#

function check_not_identically_zero(f, r)
    tmp = [f(Interval(0.0))]
    for t‚±º ‚àà 0.0:1e-3:2œÄ
        evaluate!(tmp, f, Interval(t‚±º))
        real_f = real(tmp[1])
        if (inf(real_f - r) > 0) || (sup(real_f + r) < 0)
            return true
        end
    end
    return false
end

function check_no_zeros(f, bound_Df, r, name, checknumber)
    œÄ2 = sup(2convert(Interval{Float64}, œÄ))
    t‚±º = Interval(0.0)
    tmp = [f(t‚±º)]
    count = 0
    while t‚±º < œÄ2
        evaluate!(tmp, f, t‚±º)
        real_f = real(tmp[1])
        if (inf(real_f - r) ‚â§ 0) && (0 ‚â§ sup(real_f + r))
            return false
        else
            t‚±º = Interval(inf(t‚±º + prevfloat(inf((abs(real_f) - r)/bound_Df))))
            count += 1
        end
        if count % 10_000 == 1
            print("        ‚Ä¢ check ", checknumber, ": ", name, " has no zeros in [0, ", round(inf(t‚±º); digits = 6), ")    \u001b[1000D")
        end
    end
    return true
end
